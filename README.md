<p align="center">
  <img src="https://user-images.githubusercontent.com/25181517/192149581-88194d20-1a37-4be8-8801-5dc0017ffbbe.png" width="100">
</p>
<h1 align="center">L2WB-hard_tasks</h1>

<h3 align="center">Hard quizzes, for the «L2» module in the <a href="https://tech.wildberries.ru/courses/golang/application">«Gorutin Golang»</a> course at <a href="https://tech.wildberries.ru/">«TechSchool»</a> by <a href="https://www.wildberries.ru/">«Wildberries»</a></h3>
<p align="center">Just tasks, I don't know what to say.</p>


---

### — _Tasks:_
- [**1 «Паттерны проектирования»**](pattern)
    - Реализовать паттерны, объяснить применимость каждого паттерна, плюсы и минусы, а также реальные примеры использования паттерна на практике.\
        [**1**](pattern/01_facade.go) **|** Паттерн [«Фасад»](https://en.wikipedia.org/wiki/Facade_pattern)\
        [**2**](pattern/02_builder.go) **|** Паттерн [«Строитель»](https://en.wikipedia.org/wiki/Builder_pattern)\
        [**3**](pattern/03_visitor.go) **|** Паттерн [«Посетитель»](https://en.wikipedia.org/wiki/Visitor_pattern)\
        [**4**](pattern/04_command.go) **|** Паттерн [«Команда»](https://en.wikipedia.org/wiki/Command_pattern)\
        [**5**](pattern/05_chain_of_resp.go) **|** Паттерн [«Цепочка вызовов»](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern)\
        [**6**](pattern/06_factory_method.go) **|** Паттерн [«Фабричный метод»](https://en.wikipedia.org/wiki/Factory_method_pattern)\
        [**7**](pattern/07_strategy.go) **|** Паттерн [«Стратегия»](https://en.wikipedia.org/wiki/Strategy_pattern)\
        [**8**](pattern/08_state.go) **|** Паттерн [«Состояние»](https://en.wikipedia.org/wiki/State_pattern)
- [**2 «Точное время»**](develop/dev01/task.go)
    - Создать программу, печатающую точное время с использованием _NTP_-библиотеки. Инициализировать как go module. Использовать библиотеку [github.com/beevik/ntp](http://github.com/beevik/ntp). Написать программу, печатающую текущее время / точное время с использованием этой библиотеки.\
        **_Требования:_**\
        **1** **|** Программа должна быть оформлена как _go module_.\
        **2** **|** Программа должна корректно обрабатывать ошибки библиотеки: выводить их в _STDERR_ и возвращать ненулевой код выхода в _OS_.
- [**3 «Задача на распаковку»**](develop/dev02/task.go)
    - Создать Go-функцию, осуществляющую примитивную распаковку строки, содержащую повторяющиеся символы/руны.\
        **_Например:_**
        - "a4bc2d5e" => "aaaabccddddde"
        - "abcd" => "abcd"
        - "45" => "" (некорректная строка)
        - "" => ""

        **_Дополнительно_**\
        **1 |** Реализовать поддержку _escape_-последовательностей.\
        _Например:_
        - qwe\4\5 => qwe45 (*)
        - qwe\45 => qwe44444 (*)
        - qwe\\\5 => qwe\\\\\\\\\ (*)

        **2 |** В случае если была передана некорректная строка, функция должна возвращать ошибку.\
        **3 |** Написать _unit_-тесты.
- [**4 «Утилита sort»**](develop/dev03/task.go)
    - Отсортировать строки в файле по аналогии с консольной утилитой sort (man sort — смотрим описание и основные параметры): на входе подается файл с несортированными строками, на выходе — файл с отсортированными.\
        **_Реализовать поддержку утилитой следующих ключей:_**
        - **_-k_** — указание колонки для сортировки (слова в строке могут выступать в качестве колонок, по умолчанию разделитель — пробел);
        - **_-n_** — сортировать по числовому значению;
        - **_-r_** — сортировать в обратном порядке;
        - **_-u_** — не выводить повторяющиеся строки.

        **_Дополнительно_**
        - **_-M_** — сортировать по названию месяца;
        - **_-b_** — игнорировать хвостовые пробелы;
        - **_-c_** — проверять отсортированы ли данные;
        - **_-h_** — сортировать по числовому значению с учетом суффиксов.
- [**5 «Поиск анаграмм по словарю»**](develop/dev04/task.go)
    - Написать функцию поиска всех множеств анаграмм по словарю.\
        **_Например:_**
        - 'пятак', 'пятка' и 'тяпка' — принадлежат одному множеству;
        - 'листок', 'слиток' и 'столик' — другому.

        **_Требования:_**\
        **1** **|** Входные данные для функции: ссылка на массив, каждый элемент которого — слово на русском языке в кодировке _utf8_.\
        **2** **|** Выходные данные: ссылка на мапу множеств анаграмм.\
        **3** **|** Ключ — первое встретившееся в словаре слово из множества. Значение — ссылка на массив, каждый элемент которого, слово из множества.\
        **4** **|** Массив должен быть отсортирован по возрастанию.\
        **5** **|** Множества из одного элемента не должны попасть в результат.\
        **6** **|** Все слова должны быть приведены к нижнему регистру.\
        **7** **|** В результате каждое слово должно встречаться только один раз.
- [**6 «Утилита grep»**](develop/dev05/task.go)
    - Реализовать утилиту фильтрации по аналогии с консольной утилитой (man grep — смотрим описание и основные параметры).\
        **_Реализовать поддержку утилитой следующих ключей:_**
        - **_-A_** — _"after":_ печатать _+N_ строк после совпадения;
        - **_-B_** — _"before":_ печатать _+N_ строк до совпадения;
        - **_-C_** — _"context":_ _(A+B)_ печатать _±N_ строк вокруг совпадения;
        - **_-c_** — _"count":_ количество строк;
        - **_-i_** — _"ignore-case":_ игнорировать регистр;
        - **_-v_** — _"invert":_ вместо совпадения, исключать;
        - **_-F_** — _"fixed":_ точное совпадение со строкой, не паттерн;
        - **_-n_** — _"line num":_ напечатать номер строки.
- [**7 «Утилита cut»**](develop/dev06/task.go)
    - Реализовать утилиту аналог консольной команды cut (man cut). Утилита должна принимать строки через STDIN, разбивать по разделителю (TAB) на колонки и выводить запрошенные.\
        **_Реализовать поддержку утилитой следующих ключей:_**
        - **_-f_** — _"fields":_ выбрать поля (колонки);
        - **_-d_** — _"delimiter":_ использовать другой разделитель;
        - **_-s_** — _"separated":_ только строки с разделителем.
- [**8 «Or channel»**](develop/dev07/task.go)
    - Реализовать функцию, которая будет объединять один или более done-каналов в single-канал, если один из его составляющих каналов закроется.
    - Очевидным вариантом решения могло бы стать выражение при использовании select, которое бы реализовывало эту связь, однако иногда неизвестно общее число done-каналов, с которыми вы работаете в рантайме. В этом случае удобнее использовать вызов единственной функции, которая, приняв на вход один или более or-каналов, реализовывала бы весь функционал.\
        **_Определение функции:_**
        ```go
        var or func(channels ...<- chan interface{}) <- chan interface{}
        ```
        **_Пример использования функции:_**
        ```go
        sig := func(after time.Duration) <- chan interface{} {
            c := make(chan interface{})
            go func() {
                defer close(c)
                time.Sleep(after)
            }()
            return c
        }
        
        start := time.Now()
        <-or (
            sig(2*time.Hour),
            sig(5*time.Minute),
            sig(1*time.Second),
            sig(1*time.Hour),
            sig(1*time.Minute),
        )
        
        fmt.Printf(“fone after %v”, time.Since(start))
        ```
- [**9 «Взаимодействие с ОС»**](develop/dev08/task.go)
    - Необходимо реализовать свой собственный UNIX-шелл-утилиту с поддержкой ряда простейших команд:
        - **_- cd <args>_** — смена директории (в качестве аргумента могут быть то-то и то);
        - **_- pwd_** — показать путь до текущего каталога;
        - **_- echo <args>_** — вывод аргумента в _STDOUT_;
        - **_- kill <args>_** — «убить» процесс, переданный в качестве аргумента (пример: такой-то пример);
        - **_- ps_** — выводит общую информацию по запущенным процессам в формате такой-то формат.

        Так же требуется поддерживать функционал _fork/exec_-команд.\
        Дополнительно необходимо поддерживать конвейер на пайпах (_linux pipes_, пример _cmd1 | cmd2 | .... | cmdN_).\
        **_*Шелл_** — это обычная консольная программа, которая будучи запущенной, в интерактивном сеансе выводит некое приглашение в _STDOUT_ и ожидает ввода пользователя через _STDIN_. Дождавшись ввода, обрабатывает команду согласно своей логике и при необходимости выводит результат на экран. Интерактивный сеанс поддерживается до тех пор, пока не будет введена команда выхода (например _\quit_).
- [**10 «Утилита wget»**](develop/dev09/task.go)
    - Реализовать утилиту wget с возможностью скачивать сайты целиком.
- [**11 «Утилита telnet»**](develop/dev10/task.go)
    - Реализовать простейший telnet-клиент.\
        **_Примеры вызовов:_**
        ```shell
        go-telnet --timeout=10s host port
        go-telnet mysite.ru 8080
        go-telnet --timeout=3s 1.1.1.1 123
        ```
        **_Требования:_**\
        **1** **|** Программа должна подключаться к указанному хосту (_ip_ или доменное имя + порт) по протоколу _TCP_. После подключения _STDIN_ программы должен записываться в сокет, а данные полученные из сокета должны выводиться в _STDOUT_.\
        **2** **|** Опционально в программу можно передать таймаут на подключение к серверу (через аргумент _--timeout_, по умолчанию _10s_).\
        **3** **|** При нажатии **_Ctrl+D_** программа должна закрывать сокет и завершаться. Если сокет закрывается со стороны сервера, программа должна также завершаться. При подключении к несуществующему сервер, программа должна завершаться через _timeout_.
- [**12 «HTTP-сервер»**](develop/dev11/cmd/main.go)
    - Реализовать HTTP-сервер для работы с календарем. В рамках задания необходимо работать строго со стандартной HTTP-библиотекой.\
        **_Требования:_**\
        **1** **|** Реализовать вспомогательные функции для сериализации объектов доменной области в _JSON_.\
        **2** **|** Реализовать вспомогательные функции для парсинга и валидации параметров методов _/create_event_ и _/update_event_.\
        **3** **|** Реализовать _HTTP_ обработчики для каждого из методов _API_, используя вспомогательные функции и объекты доменной области.\
        **4** **|** Реализовать _middleware_ для логирования запросов.

        **_Методы API:_**
        - POST /create_event
        - POST /update_event
        - POST /delete_event
        - GET /events_for_day
        - GET /events_for_week
        - GET /events_for_month

    - Параметры передаются в виде _www-url-form-encoded_ (т.е. обычные _user_id=3&date=2019-09-09_). В _GET_ методах параметры передаются через _queryString_, в _POST_ — через тело запроса.
    - В результате каждого запроса должен возвращаться _JSON_-документ содержащий либо _{"result": "..."}_ в случае успешного выполнения метода, либо _{"error": "..."}_ в случае ошибки бизнес-логики.\
        **_В рамках задачи необходимо:_**\
        **1** **|** Реализовать все методы.\
        **2** **|** Бизнес логика НЕ должна зависеть от кода _HTTP_ сервера.\
        **3** **|** В случае ошибки бизнес-логики сервер должен возвращать _HTTP 503_. В случае ошибки входных данных (невалидный _int_ например) сервер должен возвращать _HTTP 400_. В случае остальных ошибок сервер должен возвращать _HTTP 500_.\
        **4** **|** _Web_-сервер должен запускаться на порту указанном в конфиге и выводить в лог каждый обработанный запрос.

---
